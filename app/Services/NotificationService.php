<?php

namespace SingPlus\Services;

use Cache;
use LogTXIM;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\App;
use SingPlus\Contracts\Notifications\Constants\Notification;
use SingPlus\Contracts\Users\Services\UserService as UserServiceContract;
use SingPlus\Contracts\Users\Services\UserProfileService as UserProfileServiceContract;
use SingPlus\Contracts\Feeds\Services\FeedService as FeedServiceContract;
use SingPlus\Contracts\Works\Services\WorkService as WorkServiceContract;
use SingPlus\Contracts\Musics\Services\MusicService as MusicServiceContract;
use SingPlus\Contracts\Gifts\Services\GiftService as GiftServiceContract;
use SingPlus\Contracts\Feeds\Constants\Feed as FeedConstant;
use SingPlus\Contracts\Notifications\Services\NotificationService as NotificationServiceContract;
use SingPlus\Contracts\Notifications\Services\PushMessageService as PushMessageServiceContract;
use SingPlus\Contracts\Notifications\Constants\Notification as NotificationConstant;
use SingPlus\Contracts\Storages\Services\StorageService as StorageServiceContract;
use SingPlus\Domains\Users\Models\UserProfile;
use SingPlus\Events\Users\PushAliasBound as PushAliasBoundEvent;

class NotificationService
{
  /**
   * @var UserServiceContract
   */
  private $userService;

  /**
   * @var UserProfileServiceContract
   */
  private $userProfileService;

  /**
   * @var FeedServiceContract
   */
  private $feedService;

  /**
   * @var WorkServiceContract
   */
  private $workService;

  /**
   * @var MusicServiceContract
   */
  private $musicService;

  /**
   * @var NotificationServiceContract
   */
  private $notificationService;

  /**
   * @var PushMessageServiceContract
   */
  private $pushMessageService;

  /**
   * @var StorageServiceContract
   */
  private $storageService;

  private $giftService;

  public function __construct(
    UserServiceContract $userService,
    UserProfileServiceContract $userProfileService,
    FeedServiceContract $feedService,
    WorkServiceContract $workService,
    MusicServiceContract $musicService,
    StorageServiceContract $storageService,
    NotificationServiceContract $notificationService,
    PushMessageServiceContract $pushMessageService,
    GiftServiceContract $giftService
  ) {
    $this->userService = $userService;
    $this->userProfileService = $userProfileService;
    $this->feedService = $feedService;
    $this->workService = $workService;
    $this->musicService = $musicService;
    $this->notificationService = $notificationService;
    $this->pushMessageService = $pushMessageService;
    $this->storageService = $storageService;
    $this->giftService = $giftService;
  }

  /**
   * Bind user push alias
   *
   * @param string $userId
   * @param ?string $alias      subscribe push token generated by client
   */
  public function bindUserPushAlias(string $userId, ?string $alias)
  {
    $appChannel = config('tudc.currentChannel');
    $res = $this->userService
                ->bindUserPushAlias($appChannel, $userId, $alias);

    if ($alias) {
      event(new PushAliasBoundEvent($appChannel, $userId, $alias));
    }
    return $res;
  }

  /**
   * Get editor recommends
   *
   * @param string $userId
   * @param ?string $id       for pagination
   * @param int $size 
   *
   * @return Collection       elements as below:
   *                          - id string     unique id                 
   *                          - type string   please see SingPlus\Contracts\Notifications\Constants\PushMessage
   *                          - payload object
   *                            // for type is PushMessage::TYPE_MUSIC_SHEET
   *                            - musicSheetId string
   *                            - title string
   *                            - cover string    music sheet cover url
   *                            - text string
   *                            // for type is PushMessage::TYPE_WORK_SHEET
   *                            - workSheetId string
   *                            - title string
   *                            - cover string    music sheet cover url
   *                            - text string
   *                            // for type is PushMessage::TYPE_NEW_MUSIC
   *                            - musicId string
   *                            - text string
   *                            // for type is PushMessage::TYPE_NEW_WORK
   *                            - workId string
   *                            - text string
   *                          - createdAt \Carbon\Carbon
   */
  public function getEditorRecommends(
    string $userId,
    ?string $countryAbbr,
    ?string $id,
    int $size
  ) : Collection {
    $user = $this->userService->fetchUser($userId);
    return $this->pushMessageService
                ->getUserMessages(
                  $userId,
                  [
                    'userRegisterAt'  => $user->createdAt,
                    'countryAbbr'     => $countryAbbr,
                  ],
                  $id,
                  $size)
                ->map(function ($message, $_) {
                  if ($cover = object_get($message->payload, 'cover')) {
                    $message->payload->cover = $this->storageService->toHttpUrl($cover);
                  }

                  return $message;
                });
  }

  /**
   * notify announcement created
   */
  public function notifyAnnouncementToTopic()
  {
    return $this->notificationService
                ->notifyToTopic(
                  NotificationConstant::TOPIC_ALL,
                  NotificationConstant::TOPIC_TYPE_ANNOUNCEMENT
                );
  }

  /**
   * Send operation messages
   */
  public function notifyOperationMessages(
    array $receiptors,
    string $type,
    array $customizeData = [],
    ?string $taskId = null,
    array $userIds = []
  ) {

    if (NotificationConstant::isTopic($type)) {
      foreach ($receiptors as $receiptor) {
        $this->notificationService
             ->notifyToTopic($receiptor, $type, [], $customizeData, $taskId);
      }

    }else {
      $this->notificationService
                  ->notifyToMultiUsers($receiptors, $type, [], $customizeData, $taskId);
    }
    // send IM Messages
    $this->sendIMMessage($receiptors, $type, $customizeData, $taskId, $userIds);
  }

  /**
   * notify followed info to user who are followed
   *
   * @param string $userId          user who trigger follow action
   * @param string $followedUserId  user who was followed
   */
  public function notifyFollowedToUser(string $userId, string $followedUserId)
  {
    $appChannel = config('tudc.currentChannel');
    $alias = $this->userService->getUserPushAlias($appChannel, $followedUserId);
    if ( ! $alias) {
      return null;
    }

    // 检查是否推送消息
    if (!$this->isNotifyPrefOn(NotificationConstant::TYPE_FRIEND_FOLLOW, $followedUserId)){
        return null;
    }

    $profiles = $this->userProfileService
                     ->getUserProfiles([$userId, $followedUserId]);
    $userProfile = $profiles->where('userId', $userId)->first();
    $followedUserProfile = $profiles->where('userId', $followedUserId)->first();
    if ( ! $userProfile || ! $followedUserProfile) {
      return null;
    }

    $type = NotificationConstant::TYPE_FRIEND_FOLLOW;
    if ( ! $this->getNotifyLock($followedUserId, $type)) {
      return null;
    }

    return $this->notificationService
                ->notifyToUser(
                    $alias,
                    NotificationConstant::TYPE_FRIEND_FOLLOW,
                    [
                      'userNickname'          => (string) $userProfile->nickname,
                      'followedUserNickname'  => (string) $followedUserProfile->nickname,
                    ]);
  }

  /**
   * notify feed to user
   */
  public function notifyFeedToUser(string $feedId)
  {
    $feed = $this->feedService->getFeedForNotification($feedId);
    if ( ! $feed) {
      return null;
    }

    $validTypes = [
      FeedConstant::TYPE_WORK_FAVOURITE,
      FeedConstant::TYPE_WORK_TRANSMIT,
      FeedConstant::TYPE_WORK_COMMENT,
      FeedConstant::TYPE_WORK_CHORUS_JOIN,
      FeedConstant::TYPE_GIFT_SEND_FOR_WORK,
    ];
    if ( ! in_array($feed->type, $validTypes)) {
      return null;
    }

    // 检查是否推送消息
    if (!$this->isNotifyPrefOn($feed->type, $feed->userId)){
        return null;
    }

    $appChannel = config('tudc.currentChannel');
    $alias = $this->userService->getUserPushAlias($appChannel, $feed->userId);
    if ( ! $alias) {
      // todo log
      return null;
    }

    $profiles = $this->userProfileService->getUserProfiles([$feed->userId, $feed->operatorUserId]);
    $receptorProfile = $profiles->where('userId', $feed->userId)->first();
    $optProfile = $profiles->where('userId', $feed->operatorUserId)->first();

    if ( ! $optProfile || ! $receptorProfile) {
      // todo log
      return null;
    }
    $receptorNickname = (string) $receptorProfile->nickname;
    $optNickname = (string) $optProfile->nickname;

    switch ($feed->type) {
      case FeedConstant::TYPE_WORK_FAVOURITE :
        return $this->notifyFavouriteFeedToUser(
                        $alias, $feed->userId, $receptorNickname, $optNickname, $feed->detail->favouriteId);
      case FeedConstant::TYPE_WORK_TRANSMIT :
        return $this->notifyTransmitFeedToUser(
                        $alias, $feed->userId, $receptorNickname, $optNickname, $feed->detail->musicId);
      case FeedConstant::TYPE_WORK_COMMENT :
        return $this->notifyCommentFeedToUser(
                        $alias, $feed->userId, $receptorNickname, $optNickname, $feed->detail->commentId);
      case FeedConstant::TYPE_WORK_CHORUS_JOIN :
        return $this->notifyWorkChorusJoinFeedToUser(
          $alias, $feed->userId, $receptorNickname, $optNickname, $feed->detail->workChorusJoinId
        );
        case FeedConstant::TYPE_GIFT_SEND_FOR_WORK:
            return $this->notifyGiftSendFeedToUser(
                $alias, $feed->userId, $receptorNickname, $optNickname, $feed->detail->workId, $feed->detail->giftHistoryId);
    }

    return null;
  }

  private function notifyGiftSendFeedToUser(
      string $alias,
      string $userId,
      string $receptorNickname,
      string $optNickname,
      string $workId,
      string $giftSendHistoryId
  ){
      $giftHistory = $this->giftService->getGiftSendHistory($giftSendHistoryId);
      if (!$giftHistory){
          return null;
      }

      $data = [
          'receptorNickname' => $receptorNickname,
          'nickname'   => $optNickname,
      ];

      return $this->notificationService->notifyToUser($alias, NotificationConstant::TYPE_GIFT_SEND_FOR_WORK, $data);
  }

  private function notifyCommentFeedToUser(
    string $alias,
    string $userId,
    string $receptorNickname,
    string $optNickname,
    string $commentId
  ) {
    $comment = $this->workService->getComment($commentId, true);
    if ( ! $comment) {
      return null;
    }

    $isReplyToWork = $comment->repliedCommentId ? false : true;
    $commentType = $comment->commentType;
    // 只有普通类型的评论才推送通知
    if ($commentType != 0){
        return null;
    }
    $data = [
      'receptorNickname'  => $receptorNickname,
      'nickname'          => $optNickname,
      'isReplyToWork'     => $isReplyToWork,
      'musicName'         => null,
    ];
    if ($isReplyToWork) {
      $work = $this->workService->getDetail($comment->workId, true, true);
      if ( ! $work) {
        return null;
      }

      $music = $this->musicService->getMusic($work->musicId, true);
      if ( ! $music) {
        return null;
      }
      $data['musicName'] = $music->name;
    }

    return $this->notificationService
                ->notifyToUser($alias, NotificationConstant::TYPE_WORK_COMMENT, $data);
  }

  private function notifyTransmitFeedToUser(
    string $alias,
    string $userId,
    string $receptorNickname,
    string $optNickname,
    string $musicId
  ) {
    $type = NotificationConstant::TYPE_WORK_TRANSMIT;
    if ( ! $this->getNotifyLock($userId, $type)) {
      return null;
    }

    $music = $this->musicService->getMusic($musicId, true);
    if ( ! $music) {
      return null;
    }

    return $this->notificationService
                ->notifyToUser(
                  $alias, $type,
                  [
                    'receptorNickname'  => $receptorNickname,
                    'nickname'          => $optNickname,
                    'musicName'         => $music->name,
                    'waitNum'           => 1,
                  ]
                );
  }

  private function notifyFavouriteFeedToUser(
    string $alias,
    string $userId,
    string $receptorNickname,
    string $optNickname,
    string $favouriteId
  ) {
    $type = NotificationConstant::TYPE_WORK_FAVOURITE;
    if ( ! $this->getNotifyLock($userId, $type)) {
      return null;
    }

    $favourite = $this->workService->getFavourite($favouriteId, true);
    if ( ! $favourite) {
      return null;
    }

    $work = $this->workService->getDetail($favourite->workId, true, true);
    if ( ! $work) {
      return null;
    }

    $music = $this->musicService->getMusic($work->musicId, true);
    if ( ! $music) {
      return null;
    }

    return $this->notificationService
                ->notifyToUser(
                  $alias, $type,
                  [
                    'receptorNickname'  => $receptorNickname,
                    'nickname'          => $optNickname,
                    'musicName'         => $music->name,
                    'waitNum'           => 1,
                  ]
                );
  }

  private function notifyWorkChorusJoinFeedToUser(
    string $alias,
    string $userId,
    string $receptorNickname,
    string $optNickname,
    string $workChorusJoinId
  ) {
    return $this->notificationService
                ->notifyToUser(
                  $alias,
                  NotificationConstant::TYPE_WORK_CHORUS_JOIN,
                  [
                    'receptorNickname'  => $receptorNickname,
                    'nickname'          => $optNickname,
                    'workChorusJoinId'  => $workChorusJoinId,
                  ]
                );
  }

  private function getNotifyLock(string $userId, string $type) : bool
  {
    $expires = 10; // 10 minutes
    $key = sprintf('notify:lock:%s:%s', $userId, $type);

    return Cache::add($key, $type, $expires);
  }


  private function sendIMMessage(
      array $receiptors,
      string $type,
      array $customizeData = [],
      ?string $taskId = null,
      array $userIds = []
  ){
      LogTXIM::debug('in notifyOperation For IM', ["imTopicType" => $type]);

      if (NotificationConstant::isTopic($type)) {
          // 推送IM
          if (NotificationConstant::isTopicForIM($type)){
              $imNotificationService = App::make(\SingPlus\Domains\Notifications\Services\IMNotificationService::class);
              // 检查是否同一taskId已经发送过到其他国家了
              $hasSendOther = $this->ifTopicOtherSend($taskId, $type, $customizeData);

              LogTXIM::debug('is Topic For IM', ["imTopicType" => $type]);
              foreach ($receiptors as $receiptor){
                  if (Notification::isTopicCountryOther($receiptor)){
                      if ($hasSendOther == false){
                          LogTXIM::debug('send topic to other', ["isOther" => $hasSendOther]);
                          $imNotificationService->notifyToTopic('topic_country_other', $type, [], $customizeData);
                          $hasSendOther = true;
                          $this->setTopicOtherSend($taskId,$type,$customizeData);
                      }
                  }else {
                      LogTXIM::debug('send topic to special', ["isOther" => $hasSendOther]);
                      $imNotificationService->notifyToTopic($receiptor, $type, [], $customizeData);
                  }
              }
          }

      } else {
          // 发送im消息给用户
          if (NotificationConstant::isTypeForIM($type)){
              $imNotificationService = App::make(\SingPlus\Domains\Notifications\Services\IMNotificationService::class);
              $imNotificationService->notifyToMultiUsers($userIds, $type, [], $customizeData);
          }

      }
  }

    /**
     * @param string $userId   user who send msg
     * @param string $receiveUser   user who receive msg
     * @return null
     *
     */
  public function notifyPrivateMsgToUser(string $userId, string $receiveUser, string $redirectTo){
      $appChannel = config('tudc.currentChannel');
      $alias = $this->userService->getUserPushAlias($appChannel, $receiveUser);
      if ( ! $alias) {
          return null;
      }
      $profiles = $this->userProfileService
          ->getUserProfiles([$userId, $receiveUser]);
      $userProfile = $profiles->where('userId', $userId)->first();
      $receiveUserProfile = $profiles->where('userId', $receiveUser)->first();
      if ( ! $userProfile || ! $receiveUserProfile) {
          return null;
      }

      $type = NotificationConstant::TYPE_PRIVATE_MSG;
      if ( ! $this->getNotifyLock($receiveUser, $type)) {
          return null;
      }

      return $this->notificationService
          ->notifyToUser(
              $alias,
              NotificationConstant::TYPE_PRIVATE_MSG,
              [
                  'nickname'          => (string) $userProfile->nickname,
                  'receptorNickname'  => (string) $receiveUserProfile->nickname,
                  'redirectTo'          =>  $redirectTo,
              ]);
  }

  private function isNotifyPrefOn(string $notificationType, string $userId) : bool {
      $profile = $this->userProfileService->fetchUserProfile($userId);
      if (!$profile){
          return false;
      }
      $prefs = object_get($profile, 'preferences_conf', []);
      switch ($notificationType){
          case Notification::TYPE_WORK_FAVOURITE:
              return (bool)array_get($prefs, UserProfile::PREF_FAVOURITE, true);
          case Notification::TYPE_WORK_COMMENT:
              return (bool)array_get($prefs, UserProfile::PREF_COMMENT, true);
          case Notification::TYPE_GIFT_SEND_FOR_WORK:
              return (bool)array_get($prefs, UserProfile::PREF_GIFT, true);
          case Notification::TYPE_FRIEND_FOLLOW:
              return (bool)array_get($prefs, UserProfile::PREF_FOLLOWED, true);
      }

      return true;
  }


  // 如果customizeData没有数据，就通过判断taskId和type来确定是否发送过，否则就根据type和data来判断
  private function ifTopicOtherSend(?string $taskId, string $type, array $customizeData):bool{
      if ($customizeData == []){
          if ($taskId){
              $cacheKey = sprintf('immsg:%s:%s:topic:othercountry', $taskId, $type);
              $cacheData = Cache::get($cacheKey);
              return $cacheData ? $cacheData : false;
          }
      }else {
          $cacheKey = sprintf('immsg:%s:topic:othercountry', $type);
          $cacheData = Cache::get($cacheKey);
          if ($cacheData){
              LogTXIM::debug('check topic other send return ', ["hasSend" => true]);
              return $cacheData == $customizeData;
          }
      }

      return false;
  }

  // 设置该taskId 的topic发送到other地区的IM消息已经发送
  private function setTopicOtherSend(?string $taskId, string $type, array $customizeData){
      if ($customizeData == []){
          if ($taskId){
              $cacheKey = sprintf('immsg:%s:%s:topic:othercountry', $taskId,$type);
              Cache::put($cacheKey, true, 5);
          }
      }else {
          $cacheKey = sprintf('immsg:%s:topic:othercountry', $type);
          Cache::put($cacheKey, $customizeData, 5);
      }
  }

}
