<?php

namespace SingPlus\Http\Controllers;

use Illuminate\Support\Facades\Auth;
use Validator;
use Illuminate\Http\Request;
use SingPlus\Contracts\Works\Constants\WorkConstant;
use SingPlus\Http\Controllers\Controller;
use SingPlus\Services\WorkService;
use SingPlus\Services\WorkChorusService;
use SingPlus\Exceptions\ExceptionCode;

class WorkController extends Controller
{
  //=======================================
  //  2-steps upload workflows:
  //  one step:
  //    create upload task
  //  two step:
  //    upload work (only work file, exclude anly other arguments).
  //    Server will process work storage and create work record in db
  //
  //  note:
  //    system will clear expired task (eg: created before on day)
  //=======================================
  /**
   * Step one of 2-step upload workflow
   */
  public function createTwoStepUploadTask(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'duration'        => 'required|integer',
      'coverImageId'    => 'uuid',
      'slides'          => 'array|max:15',
      'slides.*'        => 'uuid',
      'description'     => 'nullable|string|max:300',
      'musicId'         => 'uuid',
      'workName'        => 'string|nullable|max:128',
      'needGetUploadInfo' => 'boolean',
      'secret'          => 'boolean',
      'workMimeType'    => 'workmimes',
      'chorusType'      => sprintf('integer|in:%s', implode(',', WorkConstant::$chorusTypes)),
      'originWorkId'    => sprintf('uuid|required_if:chorusType,%s', WorkConstant::CHORUS_TYPE_JOIN),
    ]);

    if (
      ! $request->request->get('musicId') &&
      ! $request->request->get('workName')
    ) {
      return $this->renderError(
        'workName required', ExceptionCode::ARGUMENTS_VALIDATION
      );
    }

    $task = $workService->createTwoStepUploadTask(
      $request->user()->id,
      $request->request->get('musicId'),
      $request->request->get('workName'),
      $request->request->get('duration'),
      $request->request->get('coverImageId'),
      $request->request->get('slides', []),
      (string) $request->request->get('description'),
      (bool) $request->request->get('needGetUploadInfo'),
      (bool) $request->request->get('secret'),
      $request->request->get('workMimeType', 'audio/mp4'),
      $request->request->get('chorusType'),
      $request->request->get('originWorkId')
    );

    return $this->renderInfo('success', [
      'taskId'    => $task->taskId, 
      'presigned' => $task->presigned,
    ]);
  }

  /**
   * Step two of 2-step upload workflow
   */
  public function twoStepUpload(
    Request $request,
    WorkService $workService,
    string $taskId
  ) {
    // check taskId
    $validator = Validator::make([
      'taskId'  => $taskId,
    ], [
      'taskId'  => 'required|uuid', 
    ]);

    if ($validator->fails()) {
      throw new WorkNotExistsException();
    }

    $this->validate($request, [
      'work'  => 'mimetypes:audio/*|max:10240',
    ]);

    $countryAbbr = $request->headers->get('X-CountryAbbr');
    $realCountryAbbr = $request->headers->get('X-RealCountryAbbr');
    $work = $workService->makeTwoStepUpload(
      $request->user()->id,
      $taskId,
      $request->file('work'),
      $countryAbbr,
      $realCountryAbbr
    );

    return $this->renderInfo('success', [
      'workId'  => $work->workId,
      'url'     => $work->url,
    ]);
  }

  /**
   * User upload his/her works
   *
   * @deprecated should use 2-steps upload workflows 
   */
  public function upload(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'duration'      => 'required|integer',
      'coverImageId'  => 'required|uuid',
      'slides'        => 'array|max:15',
      'slides.*'      => 'uuid',
      'clientId'      => 'required|uuid',       // this id generated by client
      'description'   => 'string|max:300',
      'musicId'       => 'required|uuid',
      'work'          => 'required|mimetypes:audio/*|max:10240',
    ]);

    $work = $workService->upload(
      $request->user()->id,
      $request->request->get('musicId'),
      $request->file('work'),
      $request->request->get('clientId'),
      $request->request->get('duration'),
      $request->request->get('coverImageId'),
      $request->request->get('slides', []),
      $request->request->get('description', '')
    );

    return $this->renderInfo('success', [
      'workId'  => $work->workId, 
      'url'     => $work->url,
    ]);
  }

  /**
   * Get work status by client id
   * Client use this id to check uploaded work status
   */
  public function getWorkUploadStatus(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'clientId'  => 'required|uuid',
    ]);

    $info = $workService->getWorkUploadStatus(
      $request->query->get('clientId')
    );

    return $this->renderInfo('success', [
      'isFinished'  => $info->isFinished,
      'workId'      => $info->workId,
    ]);
  }

  /**
   * User delete his/her self work
   */
  public function deleteWork(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workId'  => 'required|uuid',
    ]);

    $workService->deleteWork(
      $request->user()->id,
      $request->request->get('workId')
    );

    return $this->renderInfo('success');
  }

  /**
   * Get selection works
   */
  public function getSelections(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'selectionId'  => 'uuid|required_with:isNext',
      'isNext'  => 'boolean',
      'size'    => 'integer|min:1|max:50',
    ]);

    $countryAbbr = $request->headers->get('X-CountryAbbr');
    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id : "";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $selections = $workService->getSelections(
      $actingUserId,
      $request->query->get('selectionId'),
      (bool) $request->query->get('isNext', true),
      (int) $request->query->get('size', $this->defaultPageSize),
      $countryAbbr
    );

    return $this->render('works.selections', [
      'selections'  => $selections,
    ]);
  }

  /**
   * Get latest
   */
  public function getLatests(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workId'  => 'uuid|required_with:isNext',
      'isNext'  => 'boolean',
      'size'    => 'integer|min:1|max:50',
    ]);

    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id :"";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $works = $workService->getLatestWorks(
      $actingUserId,
      $request->query->get('workId'),
      (bool) $request->query->get('isNext', true),
      (int) $request->query->get('size', $this->defaultPageSize)
    );

    return $this->render('works.latests', [
      'works' => $works,
    ]);
  }

  /**
   * Incr work listen count
   */
  public function incrWorkListenCount(
    Request $request,
    WorkService $workService,
    string $workId
  ) {
    $request->request->set('workId', $workId);
    $this->validate($request, [
      'workId'  => 'uuid|required_with:isNext',
    ]);

    $workService->incrWorkListenCount($workId);

    return $this->renderInfo('success');
  }

  /**
   * Get work detail
   */
  public function getDetail(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workId'  => 'required|uuid',
    ]);
    $acingUser = $request->user();
    $acingUserId = $acingUser ? $acingUser->id : "";
    $acingUserId = Auth::check() ? $acingUserId : "";
    $work = $workService->getDetail(
      $request->query->get('workId'),
      false,
      $acingUserId
    );
    if ( ! $work) {
      return $this->renderError(
        'work not exists', ExceptionCode::WORK_NOT_EXISTS);
    }

    return $this->render('works.detail', [
      'work'  => $work,
    ]);
  }

  /**
   * User comment work
   */
  public function commentWork(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workId'    => 'required|uuid',
      'commentId' => 'uuid',
      'comment'   => 'required|string|max:144',
    ]);

    $realCountryAbbr = $request->headers->get('X-RealCountryAbbr');
    $comment = $workService->commentWork(
      $request->user()->id,
      $request->request->get('comment'),
      $request->request->get('workId'),
      $request->request->get('commentId'),
      $request->request->get("commentType"),
      $realCountryAbbr,
      $request->request->get("repliedUserId"),
      $request->request->get('giftFeedId')
    );

    return $this->renderInfo('success', [
      'commentId' => $comment->commentId,
    ]);
  }

  /**
   * User delete hisself comment
   */
  public function deleteWorkComment(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'commentId' => 'required|uuid',
    ]);

    $workService->deleteWorkComment(
      $request->user()->id,
      $request->request->get('commentId')
    );

    return $this->renderInfo('success');
  }

  /**
   * Get user comments
   */
  public function getComments(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workId'      => 'required|uuid',
      'commentId'   => 'uuid|required_with:isNext',
      'isNext'      => 'boolean',
      'size'        => 'integer|min:1|max:50',
    ]);

    $comments = $workService->getWorkComments(
      $request->query->get('workId'),
      $request->query->get('commentId'),
      (bool) $request->query->get('isNext', true),
      $request->query->get('size', 10)
    );

    return $this->render('works.comments', [
      'comments'  => $comments,
      'clientVersion' => $request->headers->get('X-Version'),
    ]);
  }

  /**
   * Get user related comments
   */
  public function getRelatedComments(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'commentId'   => 'uuid|required_with:isNext',
      'isNext'      => 'boolean',
      'size'        => 'integer|min:1|max:50',
    ]);

    $comments = $workService->getUserRelatedComments(
      $request->user()->id,
      $request->query->get('commentId'),
      (bool) $request->query->get('isNext', true),
      $request->query->get('size', 10)
    );

    return $this->render('messages.comments', [
      'comments'  => $comments,
    ]);
  }

  /**
   * Get user works
   */
  public function getUserWorks(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'userId'  => 'uuid',
      'workId'  => 'uuid|required_with:isNext',
      'isNext'  => 'boolean',
      'size'    => 'integer|min:1|max:50',
    ]);
    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id : "";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $userId = $request->query->get('userId');
    $works = $workService->getUserWorks(
        $actingUserId,
      $userId ?: $actingUserId,
      $request->query->get('workId'),
      (bool) $request->query->get('isNext', true),
      (int) $request->query->get('size', 10)
    );

    return $this->render('works.userWorks', [
      'works' => $works,
    ]);
  }

  /**
   * User favourit work
   *
   * 未点赞的，点赞，已点赞的取消点赞
   * 可以给自己点赞
   */
  public function favouriteWork(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workId'  => 'required|uuid',
    ]);

    $increments = $workService->favouriteWork(
      $request->user()->id,
      $request->request->get('workId')
    );

    return $this->renderInfo('success', [
              'actionNumber' => $increments, 
            ]);
  }

  /**
   * Get multi work comments and favourits
   */
  public function getMultiWorksCommentsAndFavourite(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workIds'   => 'required|array|max:10',
      'workIds.*' => 'required|uuid',
    ]);

    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id : "";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $data = $workService->getMultiWorksCommentsAndFavourite(
      $actingUserId,
      $request->query->get('workIds')
    );

    return $this->render('works.multiWorksCommentsAndFavourites', [
      'data'  => $data,
    ]);
  }

  /**
   * Get work favourits
   */
  public function getWorkFavourites(
    Request $request,
    WorkService $workService
  ) {
    $this->validate($request, [
      'workId'  => 'required|uuid',
      'id'      => 'uuid',
      'isNext'  => 'boolean',
      'size'    => 'integer|min:1|max:50',
    ]);
    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id : "";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $favourites = $workService->getWorkFavourites(
      $actingUserId,
      $request->query->get('workId'),
      $request->query->get('id'),
      (bool) $request->query->get('isNext', true),
      (int) $request->query->get('size', $this->defaultPageSize)
    );

    return $this->render('works.favourites', [
      'favourites'  => $favourites
    ]);
  }

  /**
   * Get chorus start work accompaniment
   */
  public function getChorusStartAccompaniment(
    Request $request,
    WorkService $workService,
    string $workId
  ) {
    $request->query->set('workId', $workId);

    $this->validate($request, [
      'workId'  => 'required|uuid',
    ]);

    $work = $workService->getChorusStartAccompaniment(
      $request->query->get('workId')
    );

    return $this->render('works.chorusStartAccompaniment', [
      'work'  => $work,
    ]);
  }

  /**
   * Get user chorus start works
   */
  public function getUserChorusStartWorks(
    Request $request,
    WorkService $workService,
    string $userId
  ) {
    $request->query->set('userId', $userId);

    $this->validate($request, [
      'userId'  => 'required|uuid',
      'id'      => 'uuid',
      'isNext'  => 'boolean',
      'size'    => 'integer|min:1|max:50',
    ]);
    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id : "";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $works = $workService->getUserChorusStartWorks(
      $actingUserId,
      $userId,
      $request->query->get('id'),
      $request->query->get('isNext', true),
      (int) $request->query->get('size', $this->defaultPageSize)
    );

    return $this->render('works.userChorusStartWorks', [
      'works' => $works,
    ]);
  }

  /**
   * Get all chorus joins of a specified chorus start works
   */
  public function getChorusJoinsOfChorusStart(
    Request $request,
    WorkService $workService,
    string $chorusStartWorkId
  ) {
    $request->query->set('chorusStartWorkId', $chorusStartWorkId);
    $this->validate($request, [
      'chorusStartWorkId' => 'required|uuid',
      'id'      => 'uuid',
      'isNext'  => 'boolean',
      'size'    => 'integer|min:1|max:50',
    ]);

    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id : "";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $works = $workService->getChorusJoinsOfChorusStart(
      $actingUserId,
      $chorusStartWorkId,
      $request->query->get('id'),
      $request->query->get('isNext', true),
      (int) $request->query->get('size', $this->defaultPageSize)
    );

    return $this->render('works.chorusJoinsOfChorusStart', [
      'works'  => $works,
    ]);
  }

  /**
   * Indicate whether music has work chorus start
   */
  public function musicChorusStartWorkExistence(
    Request $request,
    WorkChorusService $workChorusService,
    string $musicId
  ) {
    $request->query->set('musicId', $musicId);
    $this->validate($request, [
      'musicId'     => 'required|uuid',
    ]);

    $hasExists = $workChorusService->hasMusicOwnChorusStartWork(
      $request->query->get('musicId')
    );

    return $this->renderInfo('success', [
      'existence' => $hasExists,
    ]);
  }

  /**
   * Get recommend work sheet info
   */
  public function getRecommendWorkSheet(
    Request $request,
    WorkService $workService,
    string $sheetId
  ) {
    $request->query->set('sheetId', $sheetId);
    $this->validate($request, [
      'sheetId' => 'required|uuid',
    ]);
    $actingUser = $request->user();
    $actingUserId = $actingUser ? $actingUser->id : "";
    $actingUserId = Auth::check() ? $actingUserId : "";
    $sheet = $workService->getRecommendWorkSheet(
      $actingUserId, $sheetId
    );

    return $this->render('works.recommendWorkSheet', [
      'sheet' => $sheet,
    ]);
  }

  /**
   * Get multi work comments and favourits
   */
  public function getMultiWorksCommentsAndGifts(
      Request $request,
      WorkService $workService
  ) {
      $this->validate($request, [
          'workIds'   => 'required|array|max:10',
          'workIds.*' => 'required|uuid',
      ]);

      $actingUser = $request->user();
      $actingUserId = $actingUser ? $actingUser->id : "";
      $actingUserId = Auth::check() ? $actingUserId : "";
      $data = $workService->getMultiWorksCommentsAndGifts(
          $actingUserId,
          $request->query->get('workIds')
      );

      return $this->render('works.multiWorksCommentsAndGifts', [
          'data'  => $data,
      ]);
  }

  /**
   * @param Request $request
   * @param WorkService $workService
   * @return \Illuminate\Http\Response
   */
  public function modifyWorkInfo(
      Request $request,
      WorkService $workService
  ){
      $this->validate($request, [
          'workId'     => 'required|uuid',
          'coverImageId'      => 'uuid',
          'secret'          => 'boolean',
          'description'     => 'nullable|string|max:300',
      ]);

      $workService->modifiedWorkInfo(
          $request->user()->id,
          $request->request->get('workId'),
          $request->request->get('secret'),
          $request->request->get('coverImageId'),
          $request->request->get('description')
      );

      return $this->renderInfo('success');
  }
}
